# 不得不说的浏览器输入URL的全过程

## 前言
相信很多同学都会遇到或者在别人的面经上看到这道题，没错，这道题可以说是前端工程师的基础题，但也可以说是前端工程师最需要掌握的知识之一。今天，我们通过这篇文章来对该过程的进行一个详细的解读

# 请求

## 开始
假设我们在浏览器网址中输入https://www.baidu.com

## 浏览器准备动作

在现代浏览器上，当你在输入某串字符的过程中，它就会开始匹配你输入的内容，具体匹配内容来源是书签、历史记录以及自身缓存等，找到可以匹配到的URL，然后智能地
显式出来供用户选择，或者自动补全你的URL。对于Chrome来说,甚至可以提前从缓存中把页面加载出来，换句话说，就是当你还没有按下Enter键搜索时,页面就已经在你眼前了。

## 发起请求

按下Enter键后，那么浏览器会构建一个请求。请求行内容如下:
```js
GET /HTTP/1.1
// 请求方法是GET，请求地址为您输入的根路径，HTTP协议版本为1.1
```
## 使用缓存

在发起请求之前，浏览器会检查请求头设置的强缓存失效时间，如果命中则直接使用，否则就进入下一步。


## DNS解析

对于在连接在互联网上的每一台主机，它们都有一个属于自己的唯一ID，那就是IP地址，但是IP地址不方便人们记忆，也容易引起混记等。因此，DNS域名查询系统出现，将IP地址与域名进行一一对应。从我们输入的域名得到具体的IP地址就是一个域名解析过程，也叫DNS解析。具体的DNS解析流程为:

### 查找浏览器缓存

在现代使用的浏览器中，基本都有DNS缓存功能，如果一个域名已经被解析过，浏览器会把解析结果缓存下来，在缓存失效之前，下次请求相同域名则直接使用缓存，不需要经过后续DNS解析以加快加载速度。

### 查找系统HOST文件配置

浏览器在查找浏览器缓存，没有得到对应结果之后。则会先去本地硬盘Host文件中进行查找，看看里面有没有具体的域名与IP对应规则，如果有就直接使用，没有则进行下一步。

### 浏览器发送DNS请求到本地DNS服务器

如果本地HOST文件没有查找到相应的记录，浏览器会发送一次DNS请求到本地DNS服务器。本地DNS服务器在接收到请求之后，会先递归查找自己的缓存记录，如果有，则直接返回缓存记录，没有则向根服务器发送请求。

### 根DNS服务器

根DNS服务器在收到本地DNS服务器请求后，并不会直接返回域名和IP地址对应的关系，因为根服务器并不会存储域名和IP地址的关系，而是告诉本地DNS服务器，可以到具体的域服务器上去查找，并给出域服务器的地址，这个过程是迭代的。

### 本地DNS服务器向域服务器发送请求

本地DNS服务器在收到根DNS服务器的响应后，会向对应的域服务器发送请求，例如输入的地址是以.com结尾的，则域服务器为.com的域服务器。域服务器在收到请求之后，也不会直接返回域名和IP地址之间的对应关系。而是告诉本地服务器，你请求的域名的解析服务器的地址。

### 本地DNS服务器向解析服务器发送请求
最后，在收到域服务器的响应之后，本地DNS服务器会向解析服务器发送一个请求，获取到了一个域名和地址的对应关系，本地DNS服务器会把这个结果发送给浏览器，然后缓存这个结果

## 建立TCP连接

在获取到IP地址之后，浏览器会与域名对应的IP地址所在的主机进行TCP连接，在我们不指定端口的情况之下，浏览器会以随机端口(1024,65535)向目标主机(Web服务器程序)的80端口发起TCP连接，这个连接请求会进入内核TCP/IP的协议栈，还有可能会经过防火墙过滤，最终到达目标主机，建立TCP连接。

浏览器建立TCP连接需要经过下面三个阶段:
* 通过三次握手建立浏览器与服务端的连接
* 进行数据传输。这里有一个很重要的机制，就是接收方接收到数据包后必须要向发送方确认，如果发送方没有收到这个确认消息，就会判断为当前数据包丢失，并重新发送该数据包。当然，在这过程还有一个很重要的优化策略，就是把`大的数据包拆分成一个个小的数据包`,一次传输到接收方，接收方按照它们自身携带的顺序标志将它们组成完整的数据包。
* 断开连接，断开连接需要经过四次握手断开。

**注意:现代浏览器(以Chrome为主),在同一个域名下要求最多智能有6个TCP连接，如果超过6个，则需要等待**

## 发送HTTP请求

在建立好了TCP连接后，浏览器和我们的额服务端就可以开始通信了。浏览器发送HTTP请求必须携带三样东西:
* 请求行
* 请求头
* 请求体
具体参考[HTTP报文](https://www.jianshu.com/p/a2c4ede32d11)

## 服务器处理请求

服务器从固定的端口(一般是80)接收到的TCP报文开始，对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象供上层使用。对于一般并发量比较大的网站，都会把同一个应用部署在多个服务器中，客户端第一时间请求到的是反向代理服务器，再由反向代理服务器请求到web应用服务器。

## 响应HTTP请求

同请求类似，响应HTTP也需要三个必须要携带的东西:
* 响应体
* 响应行
* 响应头
具体参考[HTTP报文](https://www.jianshu.com/p/a2c4ede32d11)
响应完成之后，这时候需要判断请求头或者响应头中的`Connection`字段是是否为keep-live,如果是，则TCP连接会一直保存，之后请求同一个服务的资源会复用这个连接，否则就断开TCP连接，下次请求再重新建立。

# 请求的总结

到此为止，浏览器输入URL的网络请求部分，就结束了，一个大致的流程图如下。

![](http://img.stallezhou.cn/blog/url_1.png)

# 浏览器解析
完成网络请求和响应后，浏览器收到响应内容，接下来就是浏览器的解析和渲染工作了。我们首先来看解析部分，它主要分为以下几个步骤:
* 构建DOM树
* 样式计算
* 生成布局树(CSSOM)

## 构建DOM树

由于现代浏览器无法理解HTML字符串，因此需要把这一系列的字节内容转换为一种有意义且方便操作的数据结构，这种数据结构就是DOM树。DOM树本质上是一个以document为根节点的多叉树。那么浏览器是如何解析的呢

### HTMl文法的本质

首先我们应该知道一点:HTML文法并不是[上下文无关文法](https://baike.baidu.com/item/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95)。用通俗的话来说，就是上下文无关文法就是这个文法中所有产生式的左边都是一个非终结符。HTML文法是非上下文无关文法。比如一个form标签，如果它的父元素也是一个form标签，那么解析器会跳过它。

### 解析算法

H5规范详细的介绍来html的解析算法，这个算法分为两个阶段:
1. 标记化
2. 建树
对应的名词分别是`词法分析`和`语法解析`

#### 标记化算法

这个算法输入为HTML文本，输出为HTML标记。

大致的标记过程为:
1.  遇到`<`标签，状态修改为`标记打开`
2.  接收`[a-zA-z]`的字符，会进入标记名称状态，这个状态会保持到遇到`>`标签，表明标记名称完成，这时修改为`数据状态`
3.  接下来遇到`body`标签做同样的事情，此时，html和body标签都已经标记好。进入`数据状态`，之后保持这样的状态接收里面的字符。
4. 当再次遇到`<`标签时，再回到`标记打开`状态，一旦接收到下一个字符时`/`时，这时候会创建一个`end tag`的token，随后进入标记名称状态。遇到`>`的时候，再回到`数据状态`

#### 建树

之前提到过，DOM树是一棵以document为根节点的多叉树，因此解析器会先创建一个document对象，标记生成器会把每个标记的信息发送给`建树器`，建树器在收到相应的标记时，会创建对应的DOM对象。创建时会做两件事:
1. 将DOM对象加入DOM树中
2. 将对应标记压入存放开放元素的栈中

#### 容错机制

HTML5实现了很强大的容错机制，它使得我们可以在错写一些标签时按正确的方式渲染页面，比如:
* 使用`</br>`而不是`<br>`
* 表格离散后会自动转换成同一个表格
* 表单元素嵌套，会自动忽略里面的form元素

## 样式计算

关于样式计算，它的来源一般是三种:
* link标签引用
* style标签中的样式
* 元素内联样式

### 格式化样式表

首先，与html一样，浏览器无法直接识别CSS样式文本，因此渲染引擎在收到css文本之后第一件事就是将其转换为一个结构化的对象，即styleSheets。这个格式化的过程非常复杂，并且不同浏览器会用不同的优化策略，所以我们不展开讨论。我们可以在浏览器的控制台中输入document.styleSHeets来查看这个最终的结构。这个结构整合了上述三种方式来源的CSS，为后面的样式操作提供了基础。

### 标准化样式属性

有一些 CSS 样式的数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如 em -> px，red -> #ff0000，bold -> 700等。

### 计算每个节点的具体样式

样式已经被标准化和格式化了，接下来就是计算每个节点的样式信息。其实最主要的计算方式也不复杂，主要就是两个规则，`继承`和`层叠`。每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器的默认样式，这就是继承规则。

CSS 最大的贴点在于它的层叠行，也就是最终的样式取决于各个属性共同作用的效果，甚至有很多诡异的层叠现象，这里太过复杂，不展开讨论。

所有样式数值计算完毕之后，会被挂载在 window.getComputedStyle 当中，可以通过 js 来获取元素的具体样式。

## 生成布局树

现在已经生成了DOM树和CSSOM树，接下来就是要通过浏览器的布局系统来`确定元素的位置`，也就是要生成一棵`布局树（Layout Tree`。
布局树生成的工作流程大致如下：
1. 遍历生成的 DOM树节点，并把它们添加到布局树中；
2. 计算布局树节点的坐标位置。

值得注意的是，这棵布局树只包含可见元素，对于head标签或者是设置了`display: none`的元素，将不会被放入其中。

有人说会首先生成`渲染树（Render Tree）`,但这是2016年以前的事情，目前Chrome做了大量的重构，已经没有了生成渲染树的过程，并且布局树的信息非常完善，完全拥有了渲染树的功能。

# 解析总结

浏览器在收到内容后进行的解析过程大概就如上所诉，整个过程大致如下图所示:

![](http://img.stallezhou.cn/blog/url_2.png)

# 浏览器渲染
上面，我们了解了解析过程，其中包含DOM构建，样式计算以及构建布局树。接下来，我们来了解一下`渲染`。渲染可以大致分为以下几个步骤:
1. 建立`图层树(Layer Tree)`
2. 生成`绘制列表`
3. 生成`图块`并`栅格化`
4. 浏览器展示内容

## 建立图层树

如果你觉得DOM节点有了，样式和位置信息也有了，就可以开始绘制页面，那你就错了。因为我们的web应用中可能还有另外一些复杂的场景，比如 3d 动画如何呈现出变换效果，当元素含有层叠上下文是如何控制现实和隐藏等等。
为了解决上述问题，浏览器会在构建完布局树之后，还会对特定的节点进行分层，构建一棵`图层树（Layer Tree）`。那么，这棵图层树是根据什么来构建的呢？

一般情况下，节点的图层会默认属于父亲节点的图层（这些图层也称为 合成层），那么什么时候会提升为一个独立的图层呢？有两种情况需要分别讨论：
* 显式合成
* 隐式合成

### 显式合成

显式合成中又分为两种情况

1. 拥有`层叠上下文`的节点。层叠上下文是由一些特殊的CSS属性创建的，一般有以下几种情况：
* HTML 根元素本身就具有层叠上下文属性
* 普通元素 position 不等于 static，并且设置了 z-index 属性，会产生层叠上下文
* 元素的 opacity 值不是1
* 元素的 transform 值不是 none
* 元素的 filter 值不是 none
* 元素的 isolation 值不是 isolate
* `will-change`指定的属性值为上面任意一个。

2. 需要`裁剪`。比如一个 div，你只个他设置了 100 * 100 的大小，而你在里面放置了很多内容，那么超出的文字部分就会被裁剪。如果你设置了滚动条，那么滚动条也会被单独提升为一个图层。

### 隐式合成

接下来就是隐式合成，简单来说就是`层叠等级低`的节点被提升为单独的图层之后那么`所有层叠等级比它高`的节点都会成为一个单独的图层。这个隐式合成其实隐藏着一个巨大的风险，如果在一个大型应用中，当一个`z-index`比较低的元素被提升为一个单独的图层之后，层叠在它上面的元素统统都会被提升为单独的图层，可能会增加上千个图层，大大增加内存的压力，甚至直接上页面崩溃，这就是`层爆炸`的原理。
值得注意的是，当需要`重绘`的时候，只需要重绘本身，而不会影响到其他图层。

## 生成绘制列表

接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。
我们在 Chrome浏览器中，开发者工具在设置栏打开 more tools，然后选择 Layers 面板，就能够看到当前页面的绘制列表。

![](http://img.stallezhou.cn/blog/url_3.jpeg)

## 生成图块和生成位图

现在开始绘制操作，实际上渲染进程和绘制操作是由专门的线程来完成的，这个线程叫`合成线程`。

绘制列表准备好了之后，渲染进程的主线程会给合成线程发送 commit 消息，把绘制列表提交给合成线程，接下来就是合成线程工作的时候。

首先，考虑到视口就这么大，当页面非常大的时候，需要滚动非常长的时间才能滚动到底部，如果一口气全部绘制出来是非常浪费性能的，因此合成线程首先要做的就是将图层分块。这些快的大小一般不会很大，这样可以大大加快页面的首屏展示。

因为后面图块数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使绘制一部分图块，也可能会浪费大量的时间。针对这一问题，Chrome 采用了一个策略：在首次合成图块是指采用一个`低分辨率`的图块，这样首次展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容合成完毕之后，再将低分辨率的图块进行替换，这也是 Chrome 首屏加载优化的手段之一。

顺便提醒一点，渲染进程中专门维护了一个`栅格化线程池`，专门负责把`图块`转换为`位图数据`。

然后合成线程会选择适口附近的图块，。把它交给栅格化线程池生成位图。

生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给合成线程。

## 浏览器现实内容

栅格化操作完成之后，合成线程会生成一个绘制命令，并发送给浏览器进程。

浏览器进程接收到这个命令后，根据这个命令把页面内容绘制到内存，也就是生成了一个页面，然后把这部分内存发送给显卡。

无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60HZ，也就是一秒更新 60 张图片，一张图片停留的时间大约是 16.7ms，而每次更新图片都来自显卡的 `前缓冲区`，而显卡在接收到浏览器进程发送过来的页面后，会合成相应的图像，并将图像保存到`后缓冲区`，然后系统自动将前缓冲区和后缓冲区进行对调，如此循环更新。

# 渲染总结

到这里，我们把渲染的整个流程都走了一遍，大致的渲染过程如下图所示:

![](http://img.stallezhou.cn/blog/url_4.png)

# 前言
在两年的前端生涯中，我发现this指向是前端人广为讨论的一个对象，因此this也成为了一个面试热门话题。今天，我们通过本篇文章来全面地看看this的绑定问题。

# this的5种绑定规则
* 默认绑定(严格/非严格模式)
* 隐式绑定
* 显式绑定
* new绑定
* 箭头函数绑定

# this的调用位置

调用位置就是函数在代码中 **被调用的位置**，而不是函数在声明时的位置。换句话说，this的调用位置只取决于函数在运行时所调用它的位置。通常，我们有两种方法查找调用位置:
* 分析调用栈:调用位置就在当前正在执行的函数的 **前一个调用中**
* 使用开发工具得到调用栈:设置断点或者插入`debugger`;在运行时，调试器会在那个位置暂停，同事展示当前位置的函数调用列表，这就是 **调用栈**。找到栈中 **第二个元素**，这就是 **真正的调用位置**

# 绑定规则

## 默认绑定
* **独立函数调用**:可以把默认绑定看作是无法应用其他规则时的默认规则，此时this指向**全局对象**
* **严格模式**:严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined。只有函数运行在非严格模式下，默认绑定才能绑定到全局对象，在严格模式下调用函数不影响默认绑定

## 隐式绑定
当函数引用**上下文对象**时，隐式绑定会把this绑定到这个上下文对象，对象属性引用链只有上一层或者说最后一层在调用中起作用

* **隐式丢失**:被隐式绑定的函数在特定情况下会丢失绑定对象，应用默认绑定，把this绑定到全局对象下或者undefined上。
```javascript
/**
 * 虽然bar是obj.foo的一个引用,但是实际上，它引用的是foo函数本身。
 */
function foo(){
 console.log(this.a)
}
const obj = {
 a:2,
 foo:foo
}
const bar = obj.foo //函数别名
const a = 'this is global' //a是全局对象的属性

//bar()是一个不带任何修饰的函数调用，应用默认绑定
bar()   // 'this is global'
```
参数传递就是一种隐式赋值，传入函数时也会被隐式赋值，回调函数丢失this绑定也是非常常见的

## 显式绑定
通过call或者apply方法进行绑定，第一个参数是**一个对象**，在调用时会将这个对象绑定到this，显式绑定无法解决绑定丢失问题

## new绑定
在js 中，**构造函数**只是使用new操作符时被调用的普通函数，它们不属于某个类，也不会实例化一个类。
包括内置对象函数在内的所有函数都可以使用new操作符来调用，这种函数调用被称为构造函数调用。
实际上并不存在所谓的构造函数，只有对函数的**构造调用**。
使用new来调用函数，会自动执行下面的操作
1、创建一个新对象
2、这个对象会被执行[[prototype]]连接
3、这个新对象会绑定到函数调用的this
4、如果函数没有返回其他对象，那么new表达式中函数调用会自动返回这个新对象

## 箭头函数绑定
在ES6中，新增了一种特殊类型的函数,箭头函数，箭头函数无法使用上述四种规则，而是根据外层(函数或者全局)作用域(词法作用域)来决定this，而且箭头函数的绑定无法被修改

# 优先级
new绑定>显式绑定>隐式绑定>默认绑定

# 绑定例外

## 被忽略的this
把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用默认绑定。

总是传入null来忽略this可能会产生一些副作用，如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中。

更安全的做法是传入一个特殊的对象 **(空对象)**,把this绑定到这个对象中不会对你的程序产生任何的副作用

## 间接引用
间接引用下，调用这个函数会应用默认绑定规则，间接引用最容易在 **赋值时** 发生
```javascript
/**
 * p.foo  = o.foo 的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo()
*/
function foo(){
 console.log(this.a)
}
var a = 2
var o = {a:3,foo:foo}
var p = {a:4}
o.foo() // 3
(p.foo = o.foo)() //2
```
## 软绑定
* 硬绑定可以把this强制绑定到指定对象(new除外),防止函数调用默认绑定规则，但是会降低函数的灵活度，使用**硬绑定后就无法使用隐式绑定或者显式绑定来修改this**。

* 如果给默认绑定制定一个全局对象或者undefined意外事件的值，那就实现和硬绑定相同的效果，同时保留隐式绑定或显式绑定修改this的能力。
```javascript
/**
 * 默认绑定规则，优先级排最后
 * 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this，或者不会修改this
*/
if(!Function.prototype.softBind){
 Function.prototype.softBind = function(obj){
  const fn =  this
  //捕获所有curried参数
  const curried = [].slice.call(arguments,1)
  const bound = function(){
   return fn.apply((!this || this === (window||global))?obj:this,curried.concat.apply(curried,arguments))
  }
  bound.prototype = Object.create(fn.prototype)
  return bound
 }
}
```
# 总结
前端小白提醒您，this指向千万条，规则弄清第一条，代码不规范，同事两行泪
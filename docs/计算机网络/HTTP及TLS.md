# HTTP及TLS

## 前言

对于HTTP及TLS，相信很多同学都不陌生，但是我相信各位同学对于这一部分的知识都比较零散，不是很全面。今天我们就来详细的了解一下HTTP及TLS的内容。


## HTTP请求中的内容

首先，我们先来看看HTTP请求的构成，构成HTTP请求主要有三部分，分别是**请求行、首部以及实体**。

请求行大概是像 `GET /images/logo.gif HTTP/1.1`,基本请求由请求方法、URL、协议版本组成。这其中比较值得我们去了解的就是请求方法了。

请求方法有很多种，相信大家最熟悉的也是最常用的就是 `Get`和 `Post`。虽然有这么多的请求方法，但是传递给我们更多的是一个语义，而不是说`post`能做的`get`就做不到。如果你愿意，你的所有请求都用 `get` 或者都用 `post` 也是可以的，但是这违反了设计方法原则。

### 请求方法

![](http://img.stallezhou.cn/blog/http1.jpg)

从图中我们可以知道，http请求方法一共有8种，每种都有各自的语义。


### POST和GET的区别

要想了解POST和GET的区别，首先我们需要知道两个概念，`副作用`和`幂等`。

副作用通常是指对服务器上的资源做改变，搜索是无副作用的，注册和修改是有副作用的。

幂等指的是发送M和N次请求(两者不相同但是都大于1),服务器上资源的状态一致，比如注册10个和11个账号是不幂等的，对文章进行更改10次和11次是幂等的。因为前者是多了一个账号(资源)，后者只是更新了同一个资源。

在规范的应用场景上说，Get多用于无副作用，幂等的场景，例如搜索关键字。Post多用于副作用，不幂等的场景，例如注册。

在技术上说:
* Get 请求能缓存，Post 不能
* Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里（当然你想写到 `body` 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的。
* URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
* Post 支持更多的编码类型且不对数据类型限制


### 首部

首部分为请求首部和响应首部，并且部分首部两种通用，接下来我们来看看一些常用的首部。

#### 通用首部

|  通用字段   | 作用  |
|  ----  | ----  |
| Cache-Control  | 控制缓存的行为 |
| Connection  | 浏览器想要优先使用的连接类型，比如 `keep-alive` |
| Date  | 创建报文时间  |
| Pragma  | 报文指令  ｜
| Via  | 代理服务器相关信息  ｜
| Transfer-Encoding  | 传输编码方式  |
| Upgrade  | 要求客户端升级协议  ｜
| Warning  | 在内容中可能存在错误  ｜

#### 请求首部

|  请求首部   | 作用  |
|  ----  | ----  |
| Accept	  | 能正确接收的媒体类型 |
| Accept-Charset	  | 能正确接收的字符集 |
| Accept-Encoding	  | 能正确接收的编码格式列表  |
| Accept-Language	  | 能正确接收的语言列表  ｜
| Expect  | 期待服务端的指定行为  ｜
| From  | 请求方邮箱地址  |
| Host	  | 服务器的域名  ｜
| If-Match	  | 两端资源标记比较  ｜
| If-Modified-Since		  | 本地资源未修改返回 304（比较时间）  ｜
| If-None-Match		  | 本地资源未修改返回 304（比较标记）  ｜
| User-Agent		  | 客户端信息  ｜
| Max-Forwards		  | 限制可被代理及网关转发的次数  ｜
| Proxy-Authorization	  | 向代理服务器发送验证信息  ｜
| Range		  | 请求某个内容的一部分  ｜
| Referer	  | 表示浏览器所访问的前一个页面  ｜
| TE		  | 传输编码方式  ｜


#### 响应首部


|  响应首部   | 作用  |
|  ----  | ----  |
| Accept-Ranges		  | 是否支持某些种类的范围 |
| Age  | 资源在代理缓存中存在的时间  ｜
| ETag	  | 资源标识  |
| Location		  | 客户端重定向到某个 URL  ｜
| Proxy-Authorization	  | 向代理服务器发送验证信息  ｜
| Server			  | 服务器名字  ｜
| WWW-Authenticate		  | 获取资源需要的验证信息  ｜

#### 实体首部

|  实体首部   | 作用  |
|  ----  | ----  |
| Allow		  | 资源的正确请求方式 |
| Content-Encoding	  | 内容的编码格式  ｜
| Content-Language		  | 内容使用的语言  |
| Content-Length			  |  request body 长度  ｜
| Content-Location		  | 返回数据的备用地址  ｜
| Content-MD5				  | Base64加密格式的内容 MD5检验值  ｜
| Content-Range			  | 内容的位置范围  ｜
| Content-Type	  | 内容的媒体类型  |
| Expires	  | 内容的过期时间  |
| Last_modified	  | 内容的最后修改时间  |


## 常见状态码？

状态码表示了一个请求响应的状态，可以让我们清晰的了解到这一次请求是成功还是失败。所以，状态码也是传递语义的一种方式，如果我们胡乱使用状态码，那么它存在的意义就没有了。接下来我们就来看看常见的状态码

### 2XX 成功

| 状态码 | 英文名称 | 含义 |
| :-----: | :----: | :----: |
| 200 | OK | 表示从客户端发来的请求在服务器端被正确处理 |
| 204 | No content | 表示请求成功，但响应报文不含实体的主体部分 |
| 205 | Reset Content | 表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容 |
| 206 | Partial Content | 部分内容。服务器成功处理了部分GET请求（可以根据range头返回客户端需要的内容） |

### 3XX 重定向

| 状态码 | 英文名称 | 含义 |
| :-----: | :----: | :----: |
| 301 | Moved Permanently | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替（与308类似） |
| 302 | Found | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI(已经被拆分为303，307) |
| 303 | See Other | 查看其它地址。与301类似。浏览器主动使用GET和POST请求查看 |
| 304 | Not Modified | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 307 | Temporary Redirect | 临时重定向。与302类似。使用GET请求重定向 |
| 308 | Permanent Redirect | 永久重定向）是表示重定向的响应状态码，说明请求的资源已经被永久的移动到了由 Location 首部指定的 URL 上。浏览器会进行重定向，同时搜索引擎也会更新其链接（用 SEO 的行话来说，意思是“链接汁”（link juice）被传递到了新的 URL |


### 4XX 客户端错误

| 状态码 | 英文名称 | 含义 |
| :-----: | :----: | :----: |
| 400 | Bad Request | 客户端请求的语法错误，服务器无法理解 |
| 401 | Unauthorized | 请求要求用户的身份认证 |
| 403 | Forbidden | 服务器理解请求客户端的请求，但是拒绝执行此请求 |
| 404 | Not Found | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405 | Method Not Allowed | 客户端请求中的方法被禁止 |
| 408 | Request Time-out | 服务器等待客户端发送的请求时间过长，超时 |

### 5XX 服务器错误

| 状态码 | 英文名称 | 含义 |
| :-----: | :----: | :----: |
| 500 | Internal Server Error | 服务器内部错误，无法完成请求 |
| 501 | Not Implemented | 服务器不支持请求的功能，无法完成请求 |
| 502 | Bad Gateway | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503 | Service Unavailable | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504 | Gateway Time-out | 充当网关或代理的服务器，未及时从远端服务器获取请求 |
| 505 | HTTP Version not supported | 服务器不支持请求的HTTP协议的版本，无法完成处理 |

## TLS

TLS(Transport Layer Security)，全称传输层安全协定是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。

HTTPS 还是通过了HTTP来传输信息，但是信息通过TLS进行了加密。

TLS协议位于传输层之上，应用层之下。首次进行TLS协议传输需要两个RTT，接下来可以通过Session Resumption减少到一个RTT。

在TLS协议中是用了两种加密技术，分别是`对称加密`和`非对称加密`。

### 对称加密

对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。

这种加密方式固然很好，但是问题就在于如何让双方知道秘钥。因为传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，一旦秘钥被截获就没有加密的意义的。

### 非对称加密

有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。

这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在这之前，可以先使用非对称加密交换秘钥。

简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。

TLS握手过程如下:

![](http://img.stallezhou.cn/blog/http2.png)



客户端发送一个随机值以及需要的协议和加密方式。

服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）

客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书

服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密

通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。

**注意：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。**


## 小结
从上面，我们了解了HTTP的请求三大构成部分以及常用的状态码，也了解了TLS以及相关的握手过程。



